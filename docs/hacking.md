# Examples of Usage

Nachricht allows you to organize the bot code in an extensible and decoupled way. Here are several examples taken from [Begriff](https://github.com/analiz-sintez/begriff) language learning bot project.

The examples are generated by an LLM and then reviewed and edited by @krvkir, so they are correct about the architecture and guiding principles behind it.

Examples start simple and then go to extended features of the framework, so it is reasonable to read the doc from the beginning.

#### How to handle a simple command and start a process?
This example shows how to register a simple `/start` command. When triggered, it sends a welcome message and then emits a signal on the event bus to begin the onboarding process. This decouples the command invocation from the process itself.

```python
# From: app/telegram/onboarding.py

# A signal to indicate the onboarding process should begin.
@dataclass
class OnboardingStarted(Signal):
    user_id: int

# The @router.command decorator registers the function as a handler for the /start command.
# The @router.authorize decorator checks user permissions and injects a `user: User` object.
@router.command("start", description="Start using the bot")
@router.authorize()
async def start_onboarding(ctx: Context, user: User) -> None:
    """Launch the onboarding process."""
    # `ctx.send_message` sends a message to the user. It can handle
    # TranslatableStrings, automatically resolving them based on the user's locale.
    await ctx.send_message(
        _(
            """
Welcome to the Begriff Bot! I'll help you learn new words in a foreign language.

In a few steps we'll set up things and start.      
""",
        )
    )
    # `bus.emit` places a signal onto the event bus. Other parts of the system
    # can listen for this signal and react accordingly. This promotes loose coupling.
    # We pass `ctx` so the handler can use it.
    bus.emit(OnboardingStarted(user.id), ctx=ctx)

```
The `router` object serves as the primary entry point for user interactions like commands, messages, or reactions. Handlers are simple asynchronous functions that receive a `Context` object and any parameters from the decorator.

The `bus` object implements a signal/slot pattern. You `emit` signals to represent events, and handlers decorated with `@bus.on(...)` will be executed. This is ideal for chaining actions and decoupling components.

The `@router.authorize()` decorator handles user authentication. It retrieves the user from the database and injects it as a `user: User` argument into the decorated function, simplifying handlers.

#### How to handle user messages matching a pattern?
You can process any user message that doesn't start with a `/`. The `@router.message` decorator accepts a regular expression. If the pattern contains named groups, the matched values are passed as keyword arguments to the handler.

```python
# From: app/telegram/recap.py

# The pattern uses a named group `(?P<url>...)` to capture the URL.
# This `url` will be passed as a keyword argument to the `recap_url` function.
@router.message(re.compile(r"(?P<url>https?://\S+)$", re.MULTILINE))
@router.authorize()
async def recap_url(ctx: Context, user: User, url: str) -> None:
    """
    Handles messages containing a URL.

    Args:
        ctx: The context object for the current interaction.
        user: The authorized user, injected by the decorator.
        url: The URL string captured by the regex's named group.
    """
    language = get_language(
        user.get_option(
            "studied_language", Config.LANGUAGE["defaults"]["study"]
        )
    )

    # ... logic to get a recap of the URL ...
    recap = await get_recap(url, language.name, notes=None)
    response = f"{recap} [(source)]({url})"

    # Setting `reply_to=True` makes the bot's message a direct reply
    # to the user's original message.
    await ctx.send_message(
        text=response,
        reply_to=True,
    )

```
The framework passes captured named groups from the regex pattern directly to the handler function as keyword arguments. This makes extracting data from user messages straightforward. The `ctx.message` attribute provides access to the message that triggered the handler.

#### How to use inline keyboards and handle button presses?
This is a two-part process. First, you send a message with an inline keyboard. Each button in the keyboard is associated with a `Signal` instance. When a user presses a button, the framework emits that signal, which is then caught by a handler decorated with `@bus.on(...)`.

```python
# From: app/telegram/study.py

# This signal is attached to the "ANSWER" button. It carries the card's ID.
@dataclass
class CardAnswerRequested(Signal):
    card_id: int

# This function sends the initial message with the keyboard.
@bus.on(CardGraded)  # This handler can be triggered by another event.
@router.authorize()
async def study_next_card(ctx: Context, user: User) -> None:
    # ... logic to find the next card to study ...
    card = get_cards(user_id=user.id, ...)[0]

    # The Keyboard object is a list of lists of Buttons.
    # The Button's `callback` argument is a Signal instance.
    keyboard = Keyboard([[Button(_("ANSWER"), CardAnswerRequested(card.id))]])

    # The message is sent with the keyboard attached.
    return await ctx.send_message(card.front, keyboard)


# This function handles the button press.
# The `@bus.on` decorator links this handler to the `CardAnswerRequested` signal.
@bus.on(CardAnswerRequested)
@router.authorize()
async def handle_study_answer(ctx: Context, user: User, card_id: int) -> None:
    """
    Handles the "ANSWER" button press.

    Args:
        ctx: The context object.
        user: The authorized user.
        card_id: The value from the `CardAnswerRequested` signal's `card_id` field.
    """
    # ... logic to show the card's answer and a new keyboard for grading ...
    # The framework automatically unpacks the signal's fields (`card_id`)
    # and passes them as keyword arguments to the handler.
    card = get_card(card_id)
    # ...
    await ctx.send_message(f"{card.front}\n\n{card.back}", new_keyboard)
```
The core mechanic is the `Button` object, which pairs display text with a `Signal` payload. The `telegram` adapter serializes this signal into the `callback_data` field. When a button is pressed, the adapter deserializes it and emits the signal on the `bus`. The signal's dataclass fields are passed as arguments to the corresponding handler, creating a type-safe and decoupled way to handle callbacks.

#### How to build a dynamic keyboard for navigation?
For more complex interactions like a paginated list, you can dynamically generate the `Keyboard` object based on the current state. The state (e.g., current page number) is passed via the `Signal` attached to the navigation buttons.

```python
# From: app/telegram/note_list.py

# Signal for navigating the notes list. It carries all necessary state.
@dataclass
class NotesListRequested(Signal):
    user_id: int
    language_id: int
    maturity_filter: Maturity
    page: int = 1

# This function displays the list and the navigation controls.
async def display_notes_by_maturity(
    ctx: Context, user: User, language: Language, maturity_to_display: Maturity, page: int = 1
) -> None:
    all_notes = get_notes(...)
    total_pages = ...
    notes_on_page = ...

    all_keyboard_rows = []
    # Create a button for each note on the current page.
    for note_item in notes_on_page:
        all_keyboard_rows.append([Button(note_item.field1, NoteSelected(user.id, note_item.id))])

    # Create pagination buttons. Each button creates a new signal with the target page number.
    if total_pages > 1:
        pagination_row = []
        if page > 1:
            pagination_row.append(
                Button("⬅️ Prev", NotesListRequested(user.id, language.id, maturity_to_display, page - 1))
            )
        # ... more buttons for page numbers, next page etc. ...
        all_keyboard_rows.append(pagination_row)

    await ctx.send_message("List of notes...", markup=Keyboard(all_keyboard_rows))

# This handler is triggered by any of the navigation buttons.
@bus.on(NotesListRequested)
@router.authorize()
async def handle_list_notes_by_maturity_request(
    ctx: Context, user: User, language_id: int, maturity_filter: Maturity, page: int
) -> None:
    # The arguments are unpacked from the signal.
    language = get_language(language_id)
    # Re-render the list display with the new state.
    # By default, ctx.send_message will edit the existing message if called
    # from a callback query, providing a smooth navigation experience.
    await display_notes_by_maturity(ctx, user, language, maturity_filter, page)
```
This pattern creates a self-contained component. The state is not stored on the server but is encoded in the buttons themselves. When a button is pressed, the handler receives the new state, fetches the data, and re-renders the component by editing the original message.

#### How to handle message reactions?
The framework can handle reactions (e.g., 👍, 👎) to messages in a dynamic, signal-based way. When sending a message, you can specify an `on_reaction` dictionary that maps emojis to signals. When a user reacts to that message, the framework emits the corresponding signal.

```python
# From: app/telegram/note.py

# This signal is emitted when a user dislikes an explanation.
@dataclass
class NoteDownvoted(Signal):
    note_id: int

# This function sends a message and sets up a reaction handler for it.
@bus.on(WordExplanationRequested)
async def add_note(ctx: Context, user: User, text: str, ...) -> None:
    # ... logic to get or create a note ...
    note = create_word_note(...)

    # The `on_reaction` argument maps emojis to Signal instances.
    # When a user reacts with "👎", a `NoteDownvoted` signal will be emitted.
    return await ctx.send_message(
        f"🟢 *{text}* — {note.field2}",
        on_reaction={"👎": NoteDownvoted(note_id=note.id)}
    )

# This handler catches the signal emitted by the reaction.
@bus.on(NoteDownvoted)
@router.authorize()
async def handle_negative_reaction(
    ctx: Context, user: User, reply_to: Message, note_id: int
):
    """
    Handles a negative reaction to regenerate a note's explanation.

    Args:
        ctx: The context object.
        user: The authorized user.
        reply_to: The `Message` object that was reacted to, injected by the framework.
        note_id: The value from the `NoteDownvoted` signal, injected by the bus.
    """
    if not (note := get_note(note_id)):
        return

    # ... logic to regenerate the explanation for the note ...
    new_explanation = await get_explanation(note.field1, ...)
    note.field2 = new_explanation
    update_note(note)

    # Send a new message with the updated explanation.
    # We can even attach the same `on_reaction` handler to the new message.
    await ctx.send_message(
        f"🔄 *{note.field1}* — {new_explanation}",
        on_reaction={"👎": NoteDownvoted(note_id=note.id)},
    )
```
This `on_reaction` -> `Signal` -> `@bus.on` flow provides a powerful and decoupled way to add specific interactivity to messages. Instead of creating global reaction handlers with complex conditions, you attach behavior directly to the messages that need it.

#### How to manage a multi-step conversation?
For simple, sequential conversations, you can manage state using the context persistence layer. One handler can set a state flag in the user's context data, and a subsequent generic message handler can check for this flag to determine how to process the input.

```python
# From: app/telegram/note_list.py

# This handler is triggered by a button press to start the editing process.
@bus.on(NoteTitleEditRequested)
@router.authorize()
async def handle_note_title_edit_requested(
    ctx: Context, user: User, note_id: int
):
    # Set a flag in the user's persistent context to indicate an edit is active.
    # `ctx.context(user)` provides a dictionary for storing user-specific data.
    ctx.context(user)["active_edit"] = {
        "note_id": note_id,
        "field_to_edit": "field1",
    }
    await ctx.send_message("Please send the new title for the note.")


# This is a generic message handler that will catch the user's next text message.
# In the router setup, this handler is configured to run if no other more specific
# message handler matches.
@router.authorize()
async def handle_note_edit_input(ctx: Context, user: User):
    # Check if we are in an active edit session.
    active_edit_info = ctx.context(user).get("active_edit")
    if not active_edit_info:
        # Not an edit. Let other handlers process this, or do nothing.
        return

    note_id = active_edit_info["note_id"]
    new_value = ctx.message.text.strip()

    # ... logic to find the note and update it with `new_value` ...
    note_to_edit = get_note(note_id)
    note_to_edit.field1 = new_value
    db.session.commit()

    await ctx.send_message(f"Note title updated to: '{new_value}'")

    # Clean up the state flag to end the conversation.
    del ctx.context(user)["active_edit"]
```
This pattern uses `ctx.context(user)` as a simple key-value store for session state. The first function initiates the "conversation" by setting a key (`active_edit`). The next message handler checks for this key. If present, it processes the message as part of the conversation and then clears the key to end the flow. This avoids complex state machines for simple request-response interactions.


#### How to manage a multi-step conversation? The Better Way

##### Before: Using Manual State Flags

The previous implementation relied on setting a flag (`active_edit`) in the user's persistent context. A generic message handler then had to check for this flag on every incoming message. This approach is functional but can be brittle.

##### After: Using `on_reply`

The `on_reply` mechanism eliminates manual state management. When sending a message, you can specify a signal that should be emitted when the user replies to it. The framework handles the state, listening for the next message from that user and routing it to the correct signal handler.

First, we define a new signal to represent the user's input.

```python
# From: app/telegram/onboarding.py (Signal Definition)

@dataclass
class StudyLanguageEntered(Signal):
    """A user manually entered study language name."""
    user_id: int
```

Next, the handler that asks the question uses `on_reply` to register the `StudyLanguageEntered` signal to be emitted with the user's next message.

```python
# From: app/telegram/onboarding.py (Requesting Input)

@bus.on(OnboardingStarted)
@router.authorize()
async def ask_studied_language(ctx: Context, user: User):
    # ... (code to create language selection keyboard) ...

    # The key change: pass the `on_reply` argument.
    # The framework will now wait for the user's next message
    # and emit `StudyLanguageEntered` when it arrives.
    return await ctx.send_message(
        _("Select the language you want to study:"),
        keyboard,
        on_reply=StudyLanguageEntered(user_id=user.id),
        new=True,
    )
```

Finally, we create a specific signal handler that listens for `StudyLanguageEntered`. This new handler is cleaner, more focused, and does not need to manage any state flags.

```python
# From: app/telegram/onboarding.py (Handling the Input)

# This handler directly catches the user's reply.
@bus.on(StudyLanguageEntered)
@router.authorize()
async def parse_studied_language(ctx: Context, user: User):
    try:
        # ctx.message.text contains the user's reply.
        locale = Locale.parse(ctx.message.text)
        # Emit another signal to continue the flow.
        bus.emit(StudyLanguageSelected(user.id, locale.language), ctx=ctx)
    except Exception as e:
        logger.error("Exception while parsing studied language name: %s", e)
        await ctx.send_message(_("Couldn't parse the language you entered."))
```
This approach is preferable for several reasons:

-   *No State Management*: It eliminates the need to manually set and clear flags from the user's context.
-   *Decoupling*: The logic is contained in specific signal handlers (`OnboardingStarted`, `StudyLanguageEntered`) rather than a single, complex message handler that must inspect conversational state.
-   *Robustness*: It avoids conflicts between different features that might otherwise compete to handle a generic text message. The framework directs the user's reply to the correct handler automatically.

#### How to handle internationalization (i18n)?
The framework is designed for easy internationalization. You write all user-facing strings in English using the `TranslatableString` class (commonly aliased to `_`), and the framework handles translation at runtime.

```python
# From: app/telegram/onboarding.py

# It is a common convention to alias TranslatableString to a short name like _.
from nachricht.i18n import TranslatableString as _
from babel import Locale

# ...

# A TranslatableString can be used anywhere a string is expected,
# including in command descriptions.
@router.command("start", description=_("Start using the bot"))
@router.authorize()
async def start_onboarding(ctx: Context, user: User) -> None:
    # This creates a translatable object. The framework automatically collects
    # all such strings, which can then be extracted into standard .po files
    # for translators.
    await ctx.send_message(
        _(
            """
Welcome to the Begriff Bot! I'll help you learn new words in a foreign language.

In a few steps we'll set up things and start.
""",
        )
    )
    bus.emit(OnboardingStarted(user.id), ctx=ctx)


@bus.on(StudyLanguageSelected)
@router.authorize()
async def save_studied_language(ctx: Context, user: User, language_code: str):
    locale = Locale.parse(language_code)
    language = get_language(locale.get_language_name("en"))

    # TranslatableString also supports f-string-like placeholders.
    # The values are passed during the creation of the object.
    # The `resolve` function will format the translated string with these values.
    await ctx.send_message(
        _(
            "You selected: {flag}{language}",
            flag=get_flag(ctx, locale),
            language=locale.get_language_name(ctx.locale.language),
        )
    )
    bus.emit(StudyLanguageSaved(user.id, language.id), ctx=ctx)
```
The internationalization system works as follows:
1.  You define all user-facing strings as `TranslatableString("Your English string here")`.
2.  When `ctx.send_message` receives such an object, it automatically calls an internal `resolve` function, passing the string and the user's locale (`ctx.locale`).
3.  The `resolve` function looks for a translation in the appropriate `.po` file for the user's language.
4.  If a translation is found, it's returned. If not, the system can be configured to use a service (like an LLM) to generate a translation on-the-fly and save it for future use.
5.  If no translation can be found or generated, it safely falls back to the original English string.
This approach keeps the code clean and readable in one language while automating the translation process.

#### How to add contextual help messages to handlers?
You can attach a help message to the specific message sent by a handler. This help can be triggered by the user reacting to that message (e.g., with `🤔`) or replying to it with `/help`. This is achieved with the `@router.help` decorator.

```python
# From: app/telegram/study.py

from nachricht.i18n import TranslatableString as _

# ...

# The `@router.help` decorator attaches a contextual help message.
# The help text itself is a TranslatableString, so it will be internationalized.
@router.help(
    _(
        "Here you see the question. Try to remember the answer. If you come up with it, press ANSWER to check yourself. If you can't remember it for 10 seconds, don't try too hard, press ANSWER and try to memorize the answer."
    )
)
@bus.on(CardGraded)
@router.authorize()
async def study_next_card(ctx: Context, user: User):
    # ... logic to fetch a card ...
    card = get_cards(...)[0]
    note = card.note
    keyboard = Keyboard([[Button(_("ANSWER"), CardAnswerRequested(card.id))]])

    # To enable the help system, the handler MUST return the `Message` object
    # that was sent to the user.
    message = await ctx.send_message(
        card.front,
        keyboard,
        # This context is for other features, like the reaction handler for bad explanations.
        context={"note_id": note.id, "card_id": card.id},
    )
    return message # Returning the message object is critical.
```
The mechanism behind `@router.help` is powerful yet simple to use:
1.  The decorator takes a help string. It generates a unique, internal hash from this string.
2.  It automatically registers two "hidden" handlers:
    - A command handler: `@router.command("help", conditions={"_help": hash})`
    - A reaction handler: `@router.reaction(["🤔", "🤯"], conditions={"_help": hash})`
    - Both of these handlers are programmed to simply send the provided help text.
3.  The decorator then wraps your `study_next_card` function. After your function runs and returns a `Message` object, the wrapper injects the unique hash into that specific message's context: `ctx.context(message)["_help"] = hash`.
4.  Now, if a user replies `/help` to that particular message or reacts with `🤔` or `🤯`, the `conditions` of the hidden handlers are met, and the contextual help is displayed. This keeps the help system tightly coupled to the specific UI element it's explaining.
